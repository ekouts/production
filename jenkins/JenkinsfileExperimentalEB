#!/usr/bin/env groovy

def methods
def machinesList
/* 
 Initialization: checkout the production repository to load the files:
 - "util.groovy" with the functions used in the pipeline scripts
 - "Machines.groovy" with the list and properties of HPC systems
*/
stage('Initialization') {
    node('master') {
        checkout scm
        methods = load("$WORKSPACE/jenkins/util.groovy")
        machinesList = load("$WORKSPACE/jenkins/Machines.groovy")
    }
}

/* 
 Machine Selection: 
 - filters the user defined parameter "machines", accessible though "params.machines"
 - defines the runtime HPC systems of the project "machinesToRun" 
 - defines the configuration of the runtime HPC systems "machinesConfiguration"
*/
def machineConfigurations = []
stage('Machine Selection') {
    node('master') {
        def machinesToRun = machinesList.findAll({methods.machineCheck(params.machines, it.name)})
        if (!machinesToRun) {
            println "No machines were specified. Aborting...."
            currentBuild.result = "FAILURE"
            return
        }
        for (system in machinesToRun) {
            machineConfigurations.add(
                [machine:system, architectures: methods.getMachineConfiguration(
                        params.machines, system.name, system.archs as String[])])
        }
    }
}

/* 
 Build Stage: configures parallel builds for the different "machinesToRun"
 Loop over all systems in "machineConfigurations":
  - if the machine has multiple architectures, starts a sub-loop over architectures
  - the user parameter "eb_prefix" is prepended to the variable EASYBUILD_PREFIX
  - EBVERSIONEASYBUILD stores the version of EasyBuild ("params.eb_version")
  - the target CDT version is selected by the user and stored in "params.cdt_version"
*/
def builds = [:]
stage('Build Stage') {
    for (system in machineConfigurations) {
        def machine = system.machine
        def architectures = system.architectures
        def machineName = machine.name
        for (item in architectures) {
            /* define architecture and machineLabel 
               to use them in parallel builds */
            def architecture = item
            def machineLabel = architecture == "" ?
               machineName : 
               "$machineName-$architecture"
            builds["$machineLabel"] = {
                node(machineName) {
                    checkout scm

                    /* define unusePath */
                    if (machine.unusePath != '') {
                        def unusePath = architecture == '' ?  
                            "$machine.unusePath" : 
                            "$machine.unusePath".replace('ARCH', architecture)
                    }

                    /* define command to load EasyBuild */
                    def loadeasybuild = architecture == "" ?
                        "module load cdt/${params.cdt_version} EasyBuild-custom/cscs" :
                        "module load cdt/${params.cdt_version} daint-$architecture EasyBuild-custom/cscs"

                    /* define command to switch EasyBuild version*/
                    def switcheasybuild = 
                        "module switch EasyBuild EasyBuild/${params.eb_version}"

                    /* define toolchain names and corresponding EasyBuild recipes */
                    def toolchains = ['CrayCCE', 'CrayGNU', 'CrayIntel', 'CrayPGI']
                    def current_tc = toolchains.collect{"$it-${params.cdt_current}.eb"}.join(' ')
                    println "Current toolchains: $current_tc"

                    /* define command to build new toolchains */
                    def build_toolchains = architecture == "" ? 
                        "srun -u -J $env.JOB_BASE_NAME --account=${params.account} -t 00:05:00 eb $current_tc --hidden --try-software-version=${params.cdt_version}" :  
                        "srun -u -C $architecture -J $env.JOB_BASE_NAME --account=${params.account} -t 00:05:00 eb $current_tc --hidden --try-software-version=${params.cdt_version}"

                    /* build new toolchains */
                    sh("""#!/bin/bash -l
                        export EASYBUILD_PREFIX="${params.eb_prefix}/$machineLabel/${params.cdt_version}"
                        export EASYBUILD_TMPDIR="\$EASYBUILD_PREFIX/tmp"
                        export EASYBUILD_SOURCEPATH="\$EASYBUILD_PREFIX/sources"
                        export EASYBUILD_BUILDPATH="/tmp/$env.BUILD_TAG"
                        export EB_CUSTOM_REPOSITORY="$WORKSPACE/easybuild"
                        $loadeasybuild
                        $switcheasybuild
                        export EASYBUILD_EXTERNAL_MODULES_METADATA=$WORKSPACE/easybuild/cray_external_modules_metadata-${params.cdt_version}.cfg
                        eb --version
                        eb --show-config

                        echo -e "\nRunning command: \n$build_toolchains"
                        status=0
                        $build_toolchains
                        status=\$[status+\$?]
                        exit \$status""")

                    /* copy newly created toolchains to workspace */
                    for (toolchain in toolchains) {
                        def source = "${params.eb_prefix}/$machineLabel/${params.cdt_version}/software/${toolchain}/${params.cdt_version}/easybuild/reprod/${toolchain}-${params.cdt_version}.eb"
                        def target = "$WORKSPACE/easybuild/easyconfigs/c/$toolchain"
                        sh "cp ${source} ${target} || true" //TODO:Open Pull Request
                    }

                    /* build the software stack with the new toolchains */
                    def prod_file = "7.0.UP01-${params.cdt_version}-$machineLabel"
                    sh("""#!/bin/bash -l
                        export EASYBUILD_PREFIX="${params.eb_prefix}/$machineLabel/${params.cdt_version}"
                        export EASYBUILD_TMPDIR="\$EASYBUILD_PREFIX/tmp"
                        export EASYBUILD_SOURCEPATH="\$EASYBUILD_PREFIX/sources"
                        export EASYBUILD_BUILDPATH="/tmp/$env.BUILD_TAG"
                        export EB_CUSTOM_REPOSITORY="$WORKSPACE/easybuild"
                        $loadeasybuild
                        $switcheasybuild
                        export EASYBUILD_EXTERNAL_MODULES_METADATA="$WORKSPACE/easybuild/cray_external_modules_metadata-${params.cdt_version}.cfg"

                        # initialize production list
                        echo > $WORKSPACE/jenkins-builds/${prod_file}
                        build_list=\$(awk -v cdt=${params.cdt_current} '{if(\$1~cdt) print \$1}' $WORKSPACE/jenkins-builds/$machineLabel | grep -v classic)
                        for recipe in \${build_list}; do
                            status=0
                            echo -e "\nBuilding \$recipe"
                            srun -u -C $architecture -J $env.JOB_BASE_NAME --account=${params.account} -t 01:00:00 eb --try-toolchain-version=${params.cdt_version} -r \$recipe
                            status=\$[status+\$?]
                            # save successful builds in production file 
                            if [ $status -eq 0 ]; then 
                                echo \$recipe >> $WORKSPACE/jenkins-builds/${prod_file}
                                # TO DO: add successful recipes to GitHub PR
                            else
                                continue
                                # TO DO: open Jira issue or GitHub WIP PR
                            fi
                        done
                        exit \$status
#                        # find production dependencies:
#                        #cat $WORKSPACE/jenkins-builds/$prod_file
#                        awk '{print \$1}' $WORKSPACE/jenkins-builds/$prod_file | xargs -IF eb F -Dr 1> $WORKSPACE/deps.out || true
#                        #cat $WORKSPACE/deps.out
#                        cat $WORKSPACE/deps.out | grep ' \\* \\[.\\] ' | sed 's@^[^/]*/@@g' | awk '{print \$1}' | xargs basename -a | grep '\\-Cray.*-'${params.cdt_current} | sort | uniq | xargs -IF find $WORKSPACE -name F 1> $WORKSPACE/deps_clean.out
#                        #cat $WORKSPACE/deps_clean.out
#
#                        # upgrade to new cdt_version
#                        cat $WORKSPACE/deps_clean.out | xargs $WORKSPACE/easybuild/scripts/upgrade-tc.py --metadata easybuild/cray_external_modules_metadata-${params.cdt_version}.cfg --toolchain-prefix Cray --version $params.cdt_version --filenames
#                        rm $WORKSPACE/*.out
#
#                        cd $WORKSPACE/jenkins-builds
#                        sed -i 's/-${params.cdt_current}/-${params.cdt_version}/g' $prod_file
#                        ln -sf $prod_file $machineLabel
#                        #cat $machineLabel
#                        cd -
#                        #git -C $WORKSPACE status
#
#                        # dry run
#                        #echo "Debug DryRun"
#                        #find $WORKSPACE/easybuild/easyconfigs -name *-Cray*-${params.cdt_version}*.eb
#                        #echo "Debug DryRun2"
#                        #find $WORKSPACE/easybuild/easyconfigs -name *-Cray*-${params.cdt_version}*.eb | xargs srun -u -C $architecture -J $env.JOB_BASE_NAME -t 01:00:00 eb -D
#                        #echo "Debug DryRun3"
#                        #find $WORKSPACE/easybuild/easyconfigs -name *-Cray*-${params.cdt_version}*.eb | xargs -IF srun -u -C $architecture -J $env.JOB_BASE_NAME --account=${params.account} -t 01:00:00 eb -D F
#
#                        # build all new recipes
#                        status=0
#                        find $WORKSPACE/easybuild/easyconfigs -name *-Cray*-${params.cdt_version}*.eb | xargs -IF srun -u -C $architecture -J $env.JOB_BASE_NAME --account=${params.account} -t 01:00:00 eb -r F
#                        rm $WORKSPACE/*.out
#                        git -C $WORKSPACE status
#
#                        status=\$[status+\$?]
#                        exit \$status
                    """)
                }
            }
        }
    }

    try {
        parallel builds
        currentBuild.result = "SUCCESS"
    } catch(err) {
        if (err.toString().contains('exit code 143')) {
            currentBuild.result = "ABORTED"
            println "The Build step was cancelled. Aborting..."
        }
        else if (err.toString().contains('Queue task was cancelled')) {
            currentBuild.result = "ABORTED"
            println "The Queue task was cancelled. Aborting..."
        }
        else {
            currentBuild.result = "FAILURE"
            println "The Build step failed. Exiting..."
        }
    }
}
